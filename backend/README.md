# Digital Forest

## Суть Проекта (Backend-часть)

**Задача:** Создать веб-сервис "Цифровой лес".

**Ключевая функция бэкенда:** Предоставить простое, надежное и понятное **RESTful API** для фронтенд-приложения. Бэкенд будет отвечать за хранение, создание и предоставление данных о "цифровых растениях". Он не содержит сложной бизнес-логики и не занимается отображением — его единственная задача, это работа с данными.

### Суть проекта

"Цифровой лес" — это минималистичный и коллективный арт-проект. Его цель — создать общее цифровое пространство, где пользователи могут анонимно и совместно "выращивать" виртуальный лес. Каждый элемент в этом лесу — это уникальное "цифровое растение", представленное в виде пиксель-арта, которое было нарисовано и добавлено одним из посетителей. Проект сознательно избавлен от сложных функций, таких как авторизация или профили пользователей, чтобы сфокусироваться на простоте созидания и радости от обнаружения чужого творчества в постоянно меняющемся общем пространстве.

### Пользовательский опыт (User Experience)

При входе на сайт пользователь сразу же погружается в "цифровой лес" — двухмерную плоскость, на которой случайным образом отображается часть всех существующих растений. Исследуя этот лес, он может навести курсор на любое растение, чтобы увидеть небольшое всплывающее окно с информацией о том, кто и когда его "посадил". Если у пользователя возникает желание внести свой вклад, он нажимает на кнопку "Добавить свое". После этого ему открывается простой пиксельный редактор (например, с полем 64x64 пикселя), где он может нарисовать собственное уникальное растение, добавить свое имя и отправить его в общую базу данных. Его творение становится частью леса и может быть увидено другими посетителями.

---

### Что Необходимо Реализовать (План Разработки Бэкенда)

#### ✅ Шаг 1: Определение Ядра (Слой `domain`)

* **Задача:** Описать основную бизнес-сущность.
* **Файл:** `internal/domain/plant.go`
* **Что делать:**
  * Создать структуру `Plant` на чистом Go.
  * Поля: `ID (int)`, `Author (string)`, `ImageData (string)`, `CreatedAt (time.Time)`.
  * **Важно:** В этой структуре не должно быть никаких тегов (`json:"..."`, `db:"..."`). Это чистая модель данных.

#### ✅ Шаг 2: Определение Контрактов (Интерфейсы `usecase`)

* **Задача:** Определить, какие операции с данными нужны нашей бизнес-логике, не зная, как они будут реализованы.
* **Файл:** `internal/usecase/interfaces.go`
* **Что делать:**
  * Создать интерфейс `PlantRepository`.
  * Определить в нем методы:
    * `Create(ctx context.Context, plant domain.Plant) (int, error)` — создает растение и возвращает его ID.
    * `GetRandom(ctx context.Context, count int) ([]domain.Plant, error)` — получает `count` случайных растений.

#### ✅ Шаг 3: Реализация Бизнес-логики (Слой `usecase`)

* **Задача:** Написать код, который управляет процессом создания и получения растений.
* **Файл:** `internal/usecase/plant_usecase.go`
* **Что делать:**
  * Создать структуру `PlantUseCase`, которая в качестве зависимости принимает `PlantRepository` (интерфейс из Шага 2).
  * Реализовать в ней два метода:
    * `Create(...)`: Принимает простые данные (автор, изображение), создает из них `domain.Plant` и передает в метод `repo.Create`.
    * `GetRandom(...)`: Принимает количество и просто вызывает `repo.GetRandom`.

#### ✅ Шаг 4: Реализация Доступа к Данным (Слой `repository`)

* **Задача:** Написать код, который выполняет SQL-запросы к PostgreSQL.
* **Файл:** `internal/repository/postgres/plant_postgres.go`
* **Что делать:**
  * Создать структуру `PlantRepo`, которая зависит от пула соединений с БД (`*pgxpool.Pool`).
  * Реализовать в ней методы интерфейса `PlantRepository` (из Шага 2).
  * `Create`: Написать SQL-запрос `INSERT ... RETURNING id`.
  * `GetRandom`: Написать SQL-запрос `SELECT ... FROM plants ORDER BY RANDOM() LIMIT ...`.
  * Использовать библиотеку `squirrel` для построения запросов, чтобы избежать SQL-инъекций.

#### ✅ Шаг 5: Реализация API (Слой `transport/http`)

* **Задача:** Создать HTTP-эндпоинты, которые будут принимать запросы от фронтенда и вызывать бизнес-логику.
* **Файлы:**
    1. `internal/transport/http/dto.go`:
        * Создать структуры `CreatePlantRequest` и `PlantResponse` с `json` тегами. Они будут использоваться для сериализации/десериализации.
    2. `internal/transport/http/plant_handler.go`:
        * Создать два хендлера:
            * `createPlant`: читает JSON из запроса в `CreatePlantRequest`, вызывает `usecase`, преобразует результат в `PlantResponse` и отправляет JSON-ответ.
            * `getRandomPlants`: читает query-параметр `count`, вызывает `usecase`, преобразует результат и отправляет JSON-ответ.
    3. `internal/transport/http/router.go`:
        * Настроить роутер (`chi` или `gorilla/mux`).
        * Создать маршруты: `POST /plants` и `GET /plants/random`.
        * **Важно:** Добавить CORS middleware, чтобы разрешить запросы с `localhost` (где будет работать фронтенд).

#### ✅ Шаг 6: Сборка и Запуск (Слой `cmd`)

* **Задача:** "Склеить" все части вместе и запустить веб-сервер.
* **Файл:** `cmd/app/main.go`
* **Что делать:**
  * Прочитать конфигурацию (адрес БД, порт сервера).
  * Установить соединение с PostgreSQL.
  * Последовательно создать экземпляры: `Repository` -> `UseCase` -> `Router`.
  * Запустить `http.Server` с созданным роутером.

---

### Технологический стек для бэкенда

* **Язык:** Go
* **База данных:** PostgreSQL
* **Драйвер БД:** `pgx`
* **Построитель SQL-запросов:** `squirrel`
* **HTTP Роутер:** `chi` (рекомендуется как легкий и идиоматичный) или `gorilla/mux`.

### Конечный Результат (Критерии Готовности)

После выполнения этих шагов у тебя будет полностью работающий бэкенд-сервис, который:

1. Запускается одной командой (`go run ./cmd/app`).
2. Предоставляет два HTTP-эндпоинта, полностью соответствующих описанию в `api/openapi.yaml`.
3. Корректно сохраняет данные в базу данных и извлекает их оттуда.
4. Готов к интеграции с фронтендом.
